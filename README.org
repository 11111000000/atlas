#+title: Atlas — Universal Project Map for Emacs
#+author: Peter Kosov <11111000000@email.com>
#+language: en
#+startup: show2levels
[[https://github.com/11111000000/atlas/actions/workflows/ci.yml/badge.svg][CI status]]

- Overview
Atlas is a universal, extensible project map for Emacs. It builds and uses a structured map of your project: file inventory, symbols, dependencies, fast lexical retrieval, and budget-aware context planning for tasks and LLMs.

- v1 scope: Emacs Lisp projects
  - Build a map (L0 files, L1 symbols, L2 require/provide edges)
  - Incremental, deterministic indexing with TTL and change detection
  - Simple, fast lexical search with a lazy in-memory inverted index
  - Context planning: minimal spans around definitions under a token budget
  - Exports: subgraphs to DOT/Mermaid; language-agnostic JSON packs for LLMs
  - Async indexing, watch-mode, progress indicator, event bus
- Design for growth
  - Clean core + thin ports, stable alist schemas, versioned on-disk format
  - Pluggable providers (Elisp today; LSP/ctags/external later)

* Requirements
- Emacs ≥ 27.1
- Optional: ~elisp-refs~ (reserved for deeper call/ref; off by default)
- No external services; fully offline by default

- Installation
* Local clone (simplest)
- Put the repository’s =lisp/= on your =load-path= and require Atlas:
#+begin_src emacs-lisp
(add-to-list 'load-path (expand-file-name "lisp" "~/Code/atlas"))
(require 'atlas)      ;; core/entrypoint
;; Optional, for UI and exports:
(require 'atlas-ui)
(require 'atlas-export)
(require 'atlas-explore)
#+end_src

* use-package (lazy-load)
- Point ~:load-path~ to your clone:
#+begin_src emacs-lisp
(use-package atlas
  :load-path (lambda () (expand-file-name "lisp" "~/Code/atlas"))
  :commands (atlas-open atlas-close
             atlas-index atlas-reindex-changed atlas-update atlas-stats
             atlas-query-command atlas-explore
             atlas-graph-export-command atlas-export-llm-command
             atlas-watch-mode atlas-watch-add-root atlas-watch-remove-root atlas-watch-list-roots
             atlas-progress-mode
             atlas-log-open atlas-log-clear)
  :init
  ;; Optional: show indexing progress in mode-line
  (require 'atlas-ui)
  (atlas-progress-mode 1))
#+end_src

- Quick Start
* Open, index, and inspect
#+begin_src emacs-lisp
(let ((root default-directory))
  (atlas-open root)
  (atlas-index root t)   ;; full rebuild; C-u M-x atlas-index
  (atlas-stats root))    ;; => (:files N :symbols M :edges K :t-indexed SEC :schema 1)
#+end_src

* Query and jump
#+begin_src emacs-lisp
(let* ((res (atlas-query default-directory "defcustom theme" :k 10))
       (first (car res)))
  (when first
    (message "First result: %S" first)))
;; Interactive: M-x atlas-query-command
#+end_src

* Explore buffer (clickable)
#+begin_src emacs-lisp
(atlas-explore default-directory "completion table" 20)
;; RET or [Open] to jump to file/position
#+end_src

* Plan a minimal context for a task (LLM-friendly)
#+begin_src emacs-lisp
(atlas-plan-context default-directory "how to configure theme defaults?"
                    :k 12 :budget 1200 :model 'brief)
;; => (:files ... :spans ... :rationale ... :est-tokens ... :items ...)
#+end_src

* Export a graph (DOT / Mermaid)
#+begin_src emacs-lisp
(atlas-graph-export default-directory
                    '("lisp/foo.el" "feature:foo-core")
                    :depth 1 :format 'dot :path "/tmp/atlas.dot")
;; Interactive: M-x atlas-graph-export-command
#+end_src

* Export a language-agnostic JSON pack for LLMs
#+begin_src emacs-lisp
(atlas-export-llm default-directory "find defun foo"
                  :k 12 :graph-depth 1 :path "/tmp/atlas-llm.json")
;; Interactive: M-x atlas-export-llm-command
#+end_src

* Watch for changes and show progress
#+begin_src emacs-lisp
;; Watch current project (global minor-mode toggles the current default-directory)
(atlas-watch-mode 1)
;; Or manage multiple roots:
(atlas-watch-add-root default-directory)
(atlas-watch-list-roots)
;; Mode-line progress:
(require 'atlas-ui)
(atlas-progress-mode 1)
#+end_src

- Key Features (v1)
- Elisp-first map
  - L0 inventory of .el files (size, mtime, optional sha256 when enabled)
  - L1 symbols: defun/defmacro/defvar/defcustom/defconst (id, name, kind, beg/end, sig, doc1)
  - L2 edges: require/provide between file REL and feature:NAME
- Storage and performance
  - Versioned sexp files under =.context/atlas/v1=; optional gzip by suffix
  - Lazy in-memory indices; fast lexical inverted index; async + debounce
  - Deterministic exports (sorted nodes/edges/top/files/imports)
- Retrieval and context planning
  - Query over name/sig/doc1/path tokens; simple frequency + name boosts
  - Budget-aware spans around definitions; 1-hop expansion via require/provide
- Events and UX
  - Event bus for index start/progress/done/error
  - Minimal explorer buffer; clickable jumps; compact progress in mode-line

- Data and Storage
* On-disk layout (versioned)
- Root: =<project>/.context/atlas/v1/=
- Files:
  - =meta.sexp= — (:schema INT :project-root STR :generated-at FLOAT :counts plist :languages list :opts plist)
  - =files.sexp= — list of (:path REL :size INT :mtime FLOAT :hash STR|nil :lang elisp :flags plist)
  - =symbols.sexp= — list of (:id STR :file REL :name STR :kind SYM :beg INT :end INT :sig STR|nil :doc1 STR|nil :exported? BOOL :source SYM :lang SYM)
  - =edges.sexp= — list of (:type SYM :from KEY :to KEY :weight FLOAT :source SYM)
  - =summaries.sexp= — reserved
* Symbol identity
- Stable id: =LANG:REL#NAME@BEG-END/KIND= (v1 LANG=~elisp~, KIND as string)
* Incrementality
- Changed-only runs replace symbols/edges per file; inventory overwrites only when emitted
- TTL policy (~atlas-index-ttl~) decides full vs changed-only runs
- Optional content hashing (~atlas-hash-content~) for precise detection on small files

- Public API and Commands
* Lifecycle
- =(atlas-open ROOT)=, =(atlas-close ROOT)=, =(atlas-state ROOT)=, =(atlas-root-dir ROOT)=
- =(atlas-stats ROOT)= → (:files N :symbols M :edges K :t-indexed SEC :schema INT)
* Indexing
- =(atlas-index ROOT &optional FULL-OR-CHANGED)=
  - =t= → full rebuild; list-of-paths → changed-only; =nil= → TTL policy (full if stale, else changed-only)
- =(atlas-reindex-changed ROOT)= — convenience alias (TTL policy)
- =(atlas-index-async ROOT &key changed emit done)= → (:token :cancel)
- =(atlas-update ROOT PATHS)= — changed-only run for PATHS
* Query, plan, and graph
- =(atlas-query ROOT KEYWORDS &key k kinds filters)= → list of results (:type 'symbol :id :score :file :range :name :sig :doc1)
- =(atlas-plan-context ROOT QUERY &key k budget model)= → plan (:files :spans :docs :rationale :est-tokens :items)
- =(atlas-graph ROOT SELECTOR &key depth edge-types)= → (:nodes LIST :edges LIST)
* Exports
- =(atlas-graph-export ROOT SELECTOR &key depth edge-types format path)= → write DOT/Mermaid
- =(atlas-export-llm ROOT QUERY &key k budget graph-depth path)= → write JSON “rucksack”
- Interactive: =atlas-graph-export-command=, =atlas-export-llm-command=
* Events and UI
- Events: =(atlas-events-subscribe TOPIC FN)=, =(atlas-events-unsubscribe TOPIC FN)=
  - Topics: =:atlas-index-start|:atlas-index-progress|:atlas-index-done|:atlas-index-error=
- UI: =(atlas-progress-mode 1)= adds a compact mode-line segment
- Logs: =atlas-log-open=, =atlas-log-clear=
* Watch
- =(atlas-watch-mode)= — global minor-mode; toggles watching current =default-directory=
- =(atlas-watch-add-root ROOT)=, =(atlas-watch-remove-root ROOT)=, =(atlas-watch-list-roots)=

- Exports: Formats
* DOT (Graphviz)
- Deterministic, labeled edges by type
#+begin_src dot
digraph Atlas {
  rankdir=LR;
  node [shape=box];
  "lisp/foo.el";
  "feature:foo-core";
  "lisp/foo-core.el";
  "lisp/foo.el" -> "feature:foo-core" [label="require"];
  "lisp/foo-core.el" -> "feature:foo-core" [label="provide"];
}
#+end_src
* Mermaid flowchart
#+begin_src mermaid
graph LR
  N1["lisp/foo.el"]
  N2["feature:foo-core"]
  N3["lisp/foo-core.el"]
  N1 --> N2:::edge_require
  N3 --> N2:::edge_provide
#+end_src
* LLM JSON pack (brief schema)
- Language-agnostic pack with stable identifiers and deterministic ordering
#+begin_src json
{
  "query": "find defun foo",
  "top": [
    {
      "id": "elisp:lisp/foo.el#foo@80-200/function",
      "name": "foo",
      "kind": "function",
      "file": "lisp/foo.el",
      "range": [80, 200],
      "sig": "(defun foo (x y))",
      "doc1": "Return ...",
      "score": 0
    }
  ],
  "files": ["lisp/foo.el", "lisp/foo-core.el"],
  "imports": ["feature:foo-core"],
  "spans": [{"file":"lisp/foo.el","beg":60,"end":220}],
  "graph": {
    "nodes": ["feature:foo-core", "lisp/foo-core.el", "lisp/foo.el"],
    "edges": [
      {"type":"provide","from":"lisp/foo-core.el","to":"feature:foo-core"},
      {"type":"require","from":"lisp/foo.el","to":"feature:foo-core"}
    ]
  },
  "est_tokens": 180,
  "rationale": "Model=brief lexical+1hop plan under budget=1200"
}
#+end_src

- Integrations
* lore.el (optional)
- Stream Atlas results into lore retrieval/rerank:
#+begin_src emacs-lisp
(lore-getter-atlas-run
 :request (list :root default-directory :query "buffer save hooks")
 :topk 10
 :emit (lambda (item) (message "atlas→ %S" item))
 :done (lambda () (message "atlas done")))
#+end_src
* Context Navigator (placeholder)
- Build a group via =(atlas-build-context-group ...)= and export via =(atlas-export-to-context ...)= (stub to integrate later)

- Configuration
* Indexing and store
- ~atlas-index-ttl~ (float): TTL for stale detection
- ~atlas-exclude-dirs~ (list of regexps): directories to skip
- ~atlas-max-file-size~ (int): limit deep parsing on large files
- ~atlas-hash-content~ (bool): compute sha256 for precise change detection
- ~atlas-store-compressed~ (bool): write .sexp.gz files
- ~atlas-segment-threshold~ (int): reserved for future sharding
* Quality/balance
- ~atlas-elisp-use-elisp-refs~ (bool), ~atlas-elisp-refs-max-size~ (int): reserved for deeper call/ref
- ~atlas-debounce-interval~ (float): debounce async tasks
- ~atlas-parallel-limit~ (int): reserved for provider-level concurrency
* Planning
- ~atlas-plan-default-budget~ (int), ~atlas-plan-model~ (symbol)
* UI/Watch
- ~atlas-ui-progress-throttle~ (float)
- ~atlas-watch-file-regexp~ (regexp) — default targets ~\\.el\\'~

- Performance Tips
- Set ~atlas-exclude-dirs~ to skip build/vendor/git directories
- Keep ~atlas-elisp-use-elisp-refs~ off unless you need deeper edges
- Use =(atlas-index-async ...)= and watch-mode to avoid UI stalls

- Testing
* With Nix (flakes)
#+begin_src shell
nix run .#tests
# or
nix flake check -L
#+end_src
* Vanilla Emacs
#+begin_src shell
emacs -Q --batch -L lisp -l test/ert-runner.el
#+end_src

- Privacy and Offline
- No network calls; everything runs locally
- Stores live under =.context/atlas/v1=
- Logs and exports are explicit; nothing leaves your machine unless you share outputs

- Roadmap
* v1 (Elisp)
- Storage, indexing (TTL/changed-only), lexical search, planning, events, watch, explorer, DOT/Mermaid, LLM JSON
* v2 (polyglot)
- Providers for LSP/ctags/external CLI; open edge vocabulary (call/ref/import/…); optional segmentation/sharding
* v3
- Summaries pipeline, richer rerank/visualization, web viewer

- FAQ
* Does Atlas send my code anywhere?
- No. Atlas is offline by default; all data stays in your project.
* Can I use Atlas without lore/context-navigator?
- Yes. Atlas is a standalone library with interactive commands.
* Can I add other languages?
- Yes. Add/register a provider that emits normalized files/symbols/edges; core schemas are language-agnostic.

- Contributing
- See CODESTYLE.org (clean core + thin ports; pure data; small testable functions)
- Keep byte-compiler warnings at zero; add ERT tests for pure logic and schemas
- Document public function contracts and result shapes (alist keys)

- License
- Licensed under the GNU Lesser General Public License v2.1 or later (LGPL-2.1+). See =LICENSE=.

- Links
- Spec: =SPEC.org=
- Style: =CODESTYLE.org=
- Core modules: =lisp/atlas/.el=
- CI: GitHub Actions (flake-based ERT)
