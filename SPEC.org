#+title: Atlas SPEC — Универсальная карта проекта для Emacs
#+author: Peter Kosov <11111000000@email.com>
#+startup: show2levels
#+language: ru

- Введение
- Миссия
  - Atlas — модуль Emacs для построения и использования универсальной «карты проекта»: инвентарь файлов, символы, зависимости, краткие резюме, быстрый ретривал и планирование контекста под задачу.
  - Цель v1: Emacs Lisp проекты. Быстро получать минимально достаточный контекст (файлы/фрагменты/документация) для LLM и человека. Дальше — многозадачная архитектура и расширение языков (LSP/ctags/внешние источники).
- Принципы (согласно CODESTYLE.org)
  - Чистое ядро + тонкие порты; функции небольшие и тестируемые; явные данные вместо скрытых состояний.
  - Версионированные схемы; устойчивость к частичным данным; асинхронность без подвисаний.
  - Модульность и расширяемость: источники карты (elisp/LSP/ctags/внешний CLI) подключаются через единый интерфейс.
  - Оффлайн по умолчанию; хранение локально в репозитории; уважение к производительности и UX Emacs.

- Диалектика (тезис ↔ антитезис → синтез)
- Тезис: полнота и точность (AST/LSP/Graph/резюме/эмбеддинги).
- Антитезис: простота и скорость (инвентарь+rg/эвристики/консервативный парсинг).
- Синтез: многоуровневая карта, инкрементальная, с деградациями и открытыми источниками; в v1 — Elisp-first, расширение к LSP/ctags/внешним сервисам.

- Обзор возможностей (v1 → v2+)
- v1 (Emacs Lisp)
  - Построение карты:
    - L0 инвентарь .el-файлов.
    - L1 символы: defun/defmacro/defvar/defcustom/defconst (имя, вид, позиции, сигнатура, первая строка docstring).
    - L2 зависимости: require/provide (легковесный скан).
    - L3 краткие резюме — формат зарезервирован (хранилище поддерживает, наполнение отдельно).
  - Хранилище: версия схемы, meta/files/symbols/edges/summaries в sexp; опциональный gzip по суффиксу файла.
  - Модель в памяти: индексы для файлов, символов, рёбер; инвертированный индекс для быстрого поиска.
  - Поиск: лексическая токенизация name/sig/doc1/path + буст точных/префиксных совпадений.
  - План контекста (context plan): упаковка спанов вокруг дефиниций под бюджет токенов; 1-hop расширение по require/provide.
  - События: шина событий для прогресса индексации и ошибок.
  - Асинхронность: дебаунс индексации; cancel-хэндл.
  - Интеграции: lore.el (getter atlas), простой обозреватель (atlas-explore).
  - Watch-mode: file-notify для триггера частичных обновлений.
- v2+ (расширение языков/источников и функций)
  - Источники: LSP (documentSymbol/references/callHierarchy), ctags, внешние индексаторы (stdin/jsonl).
  - Больше типов рёбер: call/ref/import/implement/extend.
  - Сегментация хранилища по объёму; дополнительные индексы/эмбеддинги (опционально).
  - Визуализация графа и web-viewer/export.

- Хранилище и формат (версионированный, универсальный)
- Расположение
  - <root>/.context/atlas/v1/
- Файлы
  - meta.sexp — метаданные
  - files.sexp — инвентарь файлов
  - symbols.sexp — символы
  - edges.sexp — рёбра зависимостей
  - summaries.sexp — краткие резюме (зарезервировано)
  - inv — инвертированный индекс хранится в памяти; может быть выгружен через atlas-dump (не часть постоянного хранилища v1)
- Формы данных (plist; стабильные ключи; символы-ключи)
  - Файл:
    - (:path REL :size INT :mtime FLOAT :hash STR|nil :lang elisp :flags (:generated? t|nil :vendor? t|nil))
  - Символ:
    - (:id STR :file REL :name STR :kind function|macro|var|custom|const
       :beg INT :end INT :sig STR|nil :doc1 STR|nil :exported? t|nil :source elisp|lsp|ctags)
  - Ребро:
    - (:type require|provide|call|ref|import :from ID|REL|feature :to ID|REL|feature :weight FLOAT :source elisp|lsp|ctags)
    - В v1 используются require/provide с :from REL (файл) и :to "feature:NAME".
  - Резюме:
    - (:file REL :summary STR) | (:symbol ID :summary STR)
- Идентификатор символа (стабильный)
  - "LANG:REL#NAME@BEG-END/KIND" (в v1 LANG=elisp; KIND как строка)
- Компрессия/сегментация
  - Компрессия: включается через atlas-store-compressed и отражается в meta :opts/:compressed? t (файлы /.sexp.gz).
  - Сегментация: планируется для крупных карт (перенос в v2+); поле :segment-threshold хранится в meta как настройка.

- Пример meta.sexp
  #+begin_src emacs-lisp
  (:schema 1
   :project-root "/home/user/code/foo/"
   :generated-at 1730820000.12
   :counts (:files 128 :symbols 1640 :edges 4100)
   :languages (elisp)
   :opts (:segment-threshold 10000 :compressed? nil))
  #+end_src

- Архитектура и слои
- Модель/индексы (в памяти)
  - files-idx: path → file-plist
  - symbols-by-id: id → plist
  - symbols-by-name: name → list of id
  - edges-out: key (file REL | symbol id | feature) → list of edges
  - edges-in: key → list of edges
  - inv-index: token → vector of symbol-id (ленивое построение)
  - id->tokens: id → list of tokens (кеш для инвертированного индекса)
  - Индексы ленивые, обновляемые инкрементально при мерже батчей; на обновлениях инвертированный индекс помечается грязным.
- Источники карты (pluggable providers)
  - Интерфейс: (FN :root ROOT :changed PATHS :emit EMIT :done DONE :opts OPTS)
  - EMIT получает alist батча: (:files LIST) (:symbols LIST) (:edges LIST) (:summaries LIST) и опционально (:file REL) для замены по файлу.
  - Регистрация: atlas-register-source NAME :capabilities CAPS :fn FN :cost COST
  - capabilities: (:languages (elisp …) :kinds (files symbols edges summaries) :levels (L0 L1 L2 L3))
  - Встроенный провайдер v1: atlas-source-elisp (L0-L2).
- Хранилище
  - Чтение/запись sexp; gzip по суффиксу; единые списки на файл; миграция схем через :schema.
  - Перезапись files.sexp при наличии :files в батче.
  - Замена символов/рёбер для конкретного файла при наличии ключа (:file REL) в батче (remove-then-append).
- Ретривал и планирование контекста
  - Лексический поиск по name/sig/doc1/path; инвертированный индекс в памяти.
  - Ранжирование: частота токенов + бусты за точное/префиксное совпадение имени.
  - План контекста: упаковка спанов вокруг определений, 1-hop по require/provide, оценка токенов.

- Индексация (v1: Emacs Lisp)
- L0 Инвентарь
  - Обход каталога для /.el; исключения по atlas-exclude-dirs; TTL/mtime — на усмотрение провайдера.
  - Атрибуты: size, mtime, опц. hash (atlas-hash-content).
- L1 Символы
  - Консервативный разбор sexp (read) во временном буфере; извлечение defun/defmacro/defvar/defcustom/defconst.
  - Поля: name, kind, beg/end (позиции в файле), сигнатура (усечённая форма), doc1 (первая строка docstring).
  - Ограничение atlas-max-file-size; чтение ограничено и устойчиво к ошибкам.
- L2 Зависимости
  - Лёгкий скан текста на (provide 'foo) и (require 'bar).
  - Рёбра: :type provide|require; :from REL; :to "feature:NAME".
- L3 Резюме
  - Формат поддержан в хранилище; стратегия наполнения — отдельный поставщик/постпроцесс.
- Инкрементальность
  - Провайдер может работать в режимах: полный обход или ограничение списком файлов.
  - При :file REL в батче: для REL удаляются старые символы/рёбра и добавляются новые.
- Асинхронность/UX
  - atlas-index-async: дебаунс через run-at-time; возвращает токен и cancel-замыкание.
  - Публикация событий прогресса; безопасное логирование; отсутствие блокировок.

- API Emacs (публичные функции и команды)
- Жизненный цикл
  - atlas-open ROOT → загрузить/инициализировать состояние и индексы; вернуть state.
  - atlas-close ROOT → выгрузить состояние.
  - atlas-root-dir ROOT → путь .context/atlas/v1/.
  - atlas-state ROOT → текущее состояние (alist).
- Индексация
  - atlas-index ROOT &optional FULL-OR-CHANGED
    - t → полный пересчёт; список путей → инкремент; nil → «изменённые» по политике провайдера.
  - atlas-reindex-changed ROOT → короткий алиас для atlas-index с nil.
  - atlas-index-async ROOT &key changed emit done → (:token :cancel)
    - changed: :full | list-of-paths | nil.
  - atlas-update ROOT paths → инкрементальная индексация по путям.
  - atlas-stats ROOT → {:files N :symbols M :edges K :t-indexed SEC :schema INT}
- Поиск/граф/план
  - atlas-query ROOT keywords &key k kinds filters → список символов с score и range.
  - atlas-graph ROOT selector &key depth edge-types → подграф {:nodes LIST :edges LIST}
    - selector: REL | "feature:NAME" | symbol-id; обход BFS на заданную глубину по out/in рёбрам.
  - atlas-plan-context ROOT query &key k budget model
    - Возвращает: (:files [REL…] :spans [(:file REL :beg INT :end INT)…] :docs [] :rationale STR :est-tokens INT :items [alist…])
- Экспорт/импорт
  - atlas-dump ROOT WHAT &key format path → записывает sexp|jsonl
    - WHAT: 'all | (files symbols edges summaries inv). inv — снимок in-memory индекса.
  - atlas-import ROOT BATCH → вливает :files/:symbols/:edges/:summaries (+ опц. :file REL) в стора и модель.
- События (atlas-events)
  - atlas-events-subscribe TOPIC FN → отписка-замыкание
  - atlas-events-unsubscribe TOPIC FN
  - atlas-events-publish TOPIC &rest ARGS
  - Темы: :atlas-index-start | :atlas-index-progress | :atlas-index-done | :atlas-index-error
- Команды
  - M-x atlas-index (C-u полный)
  - M-x atlas-reindex-changed
  - M-x atlas-stats
  - M-x atlas-explore
  - M-x atlas-watch-mode
  - M-x atlas-query-command (интерактивная обёртка над atlas-query)

- Интеграция с lore.el
- Getter atlas (atlas-lore.el)
  - lore-getter-atlas-run (&key request topk emit done) — стримит результаты символов:
    - (:type symbol :title NAME|ID :snippet SIG|DOC1 :path REL :range (beg . end) :score :source atlas)
- План контекста
  - atlas-plan-context повышает приоритет результатов поиска; lore может добавлять внешние документы и rerank.

- Интеграция с Context Navigator
- Группы контекста
  - atlas-build-context-group ROOT query → {:files … :spans … :rationale … :est-tokens …}
  - atlas-export-to-context GROUP → заглушка для интеграции с Navigator.

- Конфигурация (defgroup atlas)
- Индексация и хранение
  - atlas-index-ttl (float), atlas-exclude-dirs (list regexp)
  - atlas-max-file-size (int), atlas-hash-content (bool)
  - atlas-store-compressed (bool)
  - atlas-segment-threshold (int) — порог для будущей сегментации
- Качество/баланс
  - atlas-elisp-use-elisp-refs (bool), atlas-elisp-refs-max-size (int) — резерв для расширенного анализа ссылок
  - atlas-debounce-interval (float), atlas-parallel-limit (int)
- План контекста
  - atlas-plan-default-budget (int), atlas-plan-model (symbol)

- Производительность и устойчивость
- Ленивые индексы; пере-сборка инвертированного индекса по требованию.
- Инкрементальность по файловому признаку; замена символов/рёбер для конкретного файла.
- Дебаунс асинхронных задач; отменяемые таймеры; безопасные обработчики событий.
- Исключение директорий (vendor/build/.git и т.п.); пропуск слишком больших файлов.

- Безопасность и приватность
- Оффлайн по умолчанию; внешние источники по явному включению.
- Локальное хранение в проекте; без отправки исходников.
- Логи и дампы контролируемые; избыточных данных не сохраняется.

- Версионирование и миграции
- :schema INT в meta.sexp — версия формата.
- Миграции осуществляются без потери ключевых полей; добавление новых ключей не ломает старые.
- Идентификатор символа стабилен; источники помечаются полем :source.

- Алгоритмы ретрива и «рюкзак» контекста
- Ретривал
  - Токенизация запроса; поиск в inv-index по полям name > sig > doc1 > path.
  - Слияние выдачи, скоринг по частоте; буст за точное совпадение имени (+5) и префикс (+1).
  - 1-hop расширение графом: require/provide (лимиты степени оставлены на усмотрение клиента).
- Упаковка
  - Символы: берётся сигнатура (усечённая форма), первая строка docstring и окрестность определения — ±3 строки вокруг диапазона beg..end в файле. Фактическое расширение диапазона делает планировщик по строкам, не выходя за границы буфера.
  - Файлы: список REL-файлов, которые попали в контекст напрямую или через 1-hop расширение графом (require/provide).
  - Дедупликация: по файлу/спану; пересечения спанов могут быть слиты вызывающей стороной.
  - Оценка токенов: грубо длина символов/4 для каждого спана; сумма — est-tokens. Цель — остаться под budget.
  - Выбор под бюджет: элементы добавляются в порядке релевантности (лексический скоринг), затем окрестности; при превышении бюджета добавление останавливается.

- Представления для LLM
  - brief: минимальные поля (id/name/sig/doc1/file/range) и мотивировка выбора.
  - rich: дополнительно связи, причины, оценка токенов и метаданные плана.

- Тестирование (ERT) и качество
- Тесты ядра
  - Токенизация и инвертированный индекс: детерминированность токенов, отсутствие дубликатов, корректная сборка postings.
  - Модель/идексы: мердж батчей с заменой по файлу; rebuild edges-in; очистка инвертированного индекса при изменениях.
  - Сериализация стора: чтение/запись meta/files/symbols/edges; устойчивость к пустым файлам; gzip через jka-compr при включённой опции.
- Тесты индексации (фикстуры файлов)
  - Извлечение defun/defmacro/defvar/defcustom/defconst: имя/вид/диапазон/сигнатура/doc1.
  - require/provide: корректные рёбра для feature:NAME; отсутствие ложных срабатываний на комментарии/строки.
  - Инкрементальность: замена символов/рёбер по :file; актуализация индексов; стабильность id.
- Тесты ретрива и плана
  - Скоринг по термам + бусты за точное/префиксное совпадение; ограничение top-k.
  - План под бюджет: оценка токенов; сбор спанов; 1-hop расширение по require/provide.
- Тесты событий/асинхронности
  - Шина событий: subscribe/unsubscribe/publish; исключения в обработчиках не ломают поток.
  - atlas-index-async: дебаунс, отмена таймера, завершение коллбэков без ошибок.

- Риски и контрмеры
- Большие репозитории
  - Риск: рост памяти на индексы и скорость пересчёта.
  - Контрмеры: ленивые индексы, инкрементальные батчи по файлу, дебаунс, отключение deep-парсинга для больших файлов.
- Неполные/шумные данные
  - Риск: ложные совпадения в ретривале, неполные связи.
  - Контрмеры: консервативный парсинг, чёткая схема с :source, мягкие деградации (только require/provide в v1).
- Сжатие и совместимость
  - Риск: непредсказуемость jka-compr в нестандартных окружениях.
  - Контрмеры: сжатие опционально, по суффиксу; схема неизменна; мигратор на уровне meta :schema.
- Watch-режим
  - Риск: лавина событий, гонки.
  - Контрмеры: фильтр по .el, дебаунс и async; changed-only пересчёт по относительным путям.
- Дрейф форматов
  - Риск: несовместимость между версиями.
  - Контрмеры: жёсткая фиксация :schema, добавление полей без изменения типов, миграции, ERT на сериализацию.

- Дорожная карта
- M0 (ядро хранения и API)
  - Формат .context/atlas/v1; meta/files/symbols/edges; elisp-провайдер L0/L1/L2; atlas-open/close/index/stats; события.
- M1 (ретривал и план)
  - Инвертированный индекс в памяти; atlas-query; atlas-plan-context; базовый explorer/UI; экспорт/импорт дампов.
- M2 (инкрементальность и UX)
  - watch-mode; улучшение UX обозревателя; экспорт в Context Navigator; оптимизации памяти/скорости.
- M3 (внешние источники)
  - LSP/ctags/внешние CLI-провайдеры; merge-политики по :source, новые виды рёбер.
- M4 (мультиязычность/визуализация)
  - Подключение JS/TS/Haskell источников; визуализация графа; web-viewer/export.

- Приложение A: Примеры записей
- meta.sexp
  #+begin_src emacs-lisp
  (:schema 1
   :project-root "/home/user/code/foo/"
   :generated-at 1730820000.12
   :counts (:files 128 :symbols 1640 :edges 4100)
   :languages (elisp)
   :opts (:segment-threshold 10000 :compressed? nil))
  #+end_src
- files.sexp (элемент)
  #+begin_src emacs-lisp
  (:path "lisp/foo.el" :size 8421 :mtime 1730819900.42 :hash nil :lang elisp
         :flags (:generated? nil :vendor? nil))
  #+end_src
- symbols.sexp (элемент)
  #+begin_src emacs-lisp
  (:id "elisp:lisp/foo.el#bar@120-260/function"
   :file "lisp/foo.el"
   :name "bar"
   :kind function
   :beg 120 :end 260
   :sig "(defun bar (x y))"
   :doc1 "Return combined value of X and Y."
   :exported? nil
   :source elisp)
  #+end_src
- edges.sexp (элемент)
  #+begin_src emacs-lisp
  (:type require :from "lisp/foo.el" :to "feature:foo-core" :weight 1.0 :source elisp)
  #+end_src
- summaries.sexp (элемент, зарезервировано)
  #+begin_src emacs-lisp
  (:file "lisp/foo.el" :summary "Core utilities for Foo.")
  #+end_src
- atlas-dump JSONL (фрагменты)
  #+begin_src json
  {"type":"files","data":{"path":"lisp/foo.el","size":8421,"mtime":1730819900.42,"hash":null,"lang":"elisp","flags":{"generated?":false,"vendor?":false}}}
  {"type":"symbols","data":{"id":"elisp:lisp/foo.el#bar@120-260/function","file":"lisp/foo.el","name":"bar","kind":"function","beg":120,"end":260,"sig":"(defun bar (x y))","doc1":"Return combined value of X and Y.","exported?":null,"source":"elisp"}}
  {"type":"edges","data":{"type":"require","from":"lisp/foo.el","to":"feature:foo-core","weight":1.0,"source":"elisp"}}
  {"type":"inv","token":"bar","ids":["elisp:lisp/foo.el#bar@120-260/function","elisp:lisp/qux.el#bar@44-100/function"]}
  #+end_src

- Приложение B: Контракты источников (providers)
- Интерфейс вызова
  - (FN :root ROOT :changed PATHS :emit EMIT :done DONE :opts OPTS)
  - :changed — :auto|nil|list-of-paths; list может быть относительным или абсолютным путём, провайдер нормализует.
  - EMIT получает alist батча:
    - (:files LIST) — полный снимок инвентаря (перезапись files.sexp).
    - (:symbols LIST) — список plists символов; при наличии (:file REL) заменяются записи для REL.
    - (:edges LIST) — список plists рёбер; при наличии (:file REL) заменяются записи для REL.
    - (:summaries LIST) — список plists резюме; в v1 добавляются append-only.
    - Опционально (:file REL) — привязка батча к файлу для замены соответствующих сущностей.
  - DONE вызывается один раз по завершении.
- Регистрация
  - (atlas-register-source NAME :capabilities CAPS :fn FN :cost COST)
  - :capabilities — (:languages (elisp …) :kinds (files symbols edges summaries) :levels (L0 L1 L2 L3))
  - :cost — эвристика «дороговизны».
- Политика мержа в хранилище и модели
  - files: полная перезапись при наличии ключа :files.
  - symbols/edges: remove-then-append по :file; без :file — append-only.
  - summaries: append-only в v1.
- Замечания по v1
  - Эталонный провайдер: elisp (L0-L2).
  - Рёбра: только require/provide; call/ref зарезервированы.
  - Идентификатор символа стабилен и строится на основе lang/rel/name/beg/end/kind.

- Приложение C: Представления для LLM
- brief
  #+begin_src json
  {
    "query": "fix foo: wrong arg order",
    "top": [
      {"type":"symbol","id":"elisp:lisp/foo.el#foo@80-200/function","sig":"(defun foo (y x))",
       "doc1":"Return processed pair.","file":"lisp/foo.el","range":[80,200]}
    ],
    "imports": ["feature:foo-core","feature:foo-utils"],
    "notes": "Prefer foo and callers; check require chain."
  }
  #+end_src
- rich
  #+begin_src emacs-lisp
  (:query "fix foo arg order"
   :items ((:why "name match foo; arg order suspected"
            :symbol "elisp:lisp/foo.el#foo@80-200/function"
            :span (:file "lisp/foo.el" :beg 60 :end 220)
            :tokens 120))
   :est-tokens 380
   :files ("lisp/foo.el"))
  #+end_src

- Заключение
- Atlas фиксирует простой, расширяемый и версионированный формат карты проекта, чистое ядро и тонкие порты к источникам данных.
- Версия v1 фокусируется на Emacs Lisp: инвентарь, символы, require/provide, быстрый лексический ретривал и план контекста.
- Хранилище — sexp с опциональным gzip; инвертированный индекс — только в памяти, но может быть выгружен через dump.
- Архитектура обеспечивает устойчивую инкрементальность, предсказуемые API и готовность к расширению (LSP/ctags/внешние источники) без ломки базовых контрактов.
